# 第二章 用隐喻来更充分的理解软件开发

1. 隐喻的重要性：隐喻即是类比。
2. 隐喻不会告诉我们答案在哪里，而是告诉我们如何寻找答案：隐喻不是算法，具有不确定性。隐喻只能给你大致的思考方向；甚至可能是错的。

# 第三章 前期准备

## 问题定义的先决条件

问题定义： 只定义问题是什么？而不是定义问题的解决方案。

如：我们快无法完成订单了。而不是：我们需要优化系统，使我们完成订单。

问题定义应该尽可能的使用客户的语言去描述问题。

**未能定义问题**带来的后果：花费大量时间去解决错误的问题。

## 架构的典型组成成分

设计架构图：应将各个模块的责任分析清楚，并明确定义各个模块的功能，使各个模块对其他模块的了解达到最小。并明确描述模块之间能否**直接使用、间接使用、无法使用**。

主要的类：应该将各个类的责任和交互进行描述，包含：状态转换、持久化、继承体系等。并记述曾经考虑过的其他类设计方案。

数据设计：描述主要文件和数据表的设计。并将为何这样设计的原因以及为什么没有选其他方案的原因进行解释。并解释为何使用不同的数据存储组件或架构，如：为何使用单数据库（或多数据库）、为何使用缓存（redis）等。

业务规则：如果架构依赖与特定的业务规则。那就应该详细的描述这些业务规则对架构的影响。

资源管理：架构应该描述管理稀缺资源的计划。如数据库连接数量、线程数量、内存量等。架构应该可以估算出正常和极限情况下的资源使用量。

安全性：对应有的访问权限的控制的设计，以及配置文件和cookie等数据的访问控制。

性能：评估出性能目标，以及达到性能的目标的预期资源使用。并指出为什么可以达到性能预期；以及使用了哪些特定的算法和数据结构来优化性能也应该进行描述。

可伸缩性：对系统增长以满足未来需求的能力。架构应该描述系统如何应对用户数量、服务器数量、网络节点数量、数据记录数量的增长。

错误处理：

* 对错误进行纠错还是检测：如果是纠错就应该尝试从错误中恢复过来。如果是检测则就当“无事发生”一样继续执行接下来的操作或者退出。但无论是哪一种情况，都应该进行记录并通知。
* 错误检测是主动的还是被动的：例如主动检测用户的输入信息，或被动的当数据发生错误时进行被动的错误处理。但无论是哪一种情况，都会对界面造成一定的影响。
* 程序应该如何传递错误：程序一旦检测到错误的数据，可以立刻丢弃引发错误的数据。也可以把这个错误数据当成一个错误，并进入错误处理状态。或可以将错误的数据暂存下来，并在处理完成后，在通知用户错误的位置。
* 错误处理的信息有什么约定：架构应该制定一套错误规范。保证所有错误都在该规范中进行处理。
* 如何处理异常：架构应该规定代码何时可以抛出异常，在什么地方进行异常的捕获。如何记录异常，以及如何描述异常。
* 在程序中，在什么层次上处理错误：1. 在发现错误的地方处理错误。2. 调用专门的错误处理类对错误进行处理。3. 沿着调用链将错误向上传递。
* 每个类在验证其输入数据的有效性方面应该有什么责任：每个类自己验证自己的数据有效性还是有一组验证器来验证数据的有效性。能否在某个层次上认为默认数据是正确的。
* 应该使用内建的错误处理机制还是使用某种特定的错误处理方法。

容错性：架构应该详细定义所期望的容错种类。包含：错误检测以及错误恢复。当错误无法修复时，则应该包容错误。

架构的可行性：架构应该论证系统的技术可行性。如果任何一个方面不可行会导致项目无法实施。那么架构应该说明如何解决这方面的问题。

过度工程：应该对不同的模块的健壮性规定不同的级别。对于某些无关紧要的模块可以进行简单的设计，而对于重要的模块则需要进行过度设计来保证其健壮性。

“买”还是“造”的决策：当架构需要用到某些组件，而这些组件是可以购买或直接使用的。则应该说明自己定制的组件应该在哪方面胜过现有的组件或程序。

关于复用的决策：如果架构中使用了已存在的工具或组件。应该说明当需要对复用的软件进行拓展时，如何对复用的软件进行加工以满足需求。

更变策略：架构应该提供一定的更变灵活性。并描述考虑过的有可能更变的原因。并说明“最有可能更变的功能也是最容易实现的”。架构应该指出动态绑定数据所用到的策略。如将数据保存在外部文件，而非硬编码。这样就可以在不更变代码的前提下修改程序的功能。

架构总体质量：优秀的架构说明书，讨论了系统的模块背后的隐藏信息、讨论了”采用或排斥所有可能设计替代方案的“的根本原因。

架构的顶层设计：应该独立于特定语言或机器。

# 第五章 软件构建中的设计

**重中之重：对于系统层的软件设计图应该是无环图。即：模块A->模块B->模块C。而不能是:模块A->模块B->模块C->模块A。**

**常见的子系统/模块：业务规则子系统/模块，用户界面子系统/模块，数据库访问子系统/模块，依赖操作系统的子系统/模块**

**找出现实中的对象**：通过理解现实中的对象来刻画系统中的对象应该是什么样子的，包含：共有方法，私有方法，成员变量。

**抽象能力非常重要！**

**封装用以实现抽象后的细节**

**信息隐藏对应设计非常有帮助**

**找到容易改变的区域并将其限制在一个子系统中，而不是分布在各个位置，常见的有：**

1. 业务规则
2. 对硬件和操作系统的依赖
3. 输入和输出
4. 状态变量

**耦合标准的定义：**

1. 调用方与被调用方的参数传递越少则耦合关系越松散
2. 被调用方的共有方法越少则耦合关系越松散
3. 调用方与被调用方的使用全局数据进行信息的交互与参数传递进行信息交互，参数传递的耦合关系更为松散
4. 一个模块越容易被其他模块调用，则耦合关系越松散

**常见的耦合种类:**

1. 简单数据参数耦合：当传递的参数是简单数据类型时，这个耦合关系是正常的。
2. 简单对象耦合：如果一个模块持有一个实例化的对象，那这种属于简单对象耦合，这种耦合关系是不错的。
3. 对象参数耦合：当A传递传递参数给B的参数是对象C，则相比于简单数据参数耦合，这种耦合更为紧密。
4. 语义上的耦合：

   * 当A传递一个标志位给B来执行对应的操作，则A需要了解B中的细节才能传递对应的标志位。如果需要这样做则应该将标志位设置为枚举值或对象。

   * 当A需要使用B时，需要先调用B的init才能使用B，则存在语义上的耦合。

   * 当A需要修改B的全局变量，则需要A先确定修改的结果是否符合预期，这种也存在语义上的耦合。

   * 当A将C传给B进行初始化，而B只对C进行部分初始化以满足A的需求。这种也是语义上的耦合。

   * 当A将抽象类C传给B，而B知道C的实际实现类D，则B将C强转为D并使用D特有的功能进行处理，这种也存在语义上的耦合。

     * 语义上的耦合非常的危险，因为更改被调用模块的代码可能会破坏调用它的模块。并且破坏的方式编译器完全无法检测。

**其他启发式方法**

1. 高内聚性
2. 项目构造分层架构
3. 严格描述类的职责
4. 分配职责
5. 为测试而设计
6. 避免失误
7. 有意识的选择绑定时间
8. 创建中心控制点
9. 考虑使用蛮力
10. 画图
11. 保持设计的模块化

**设计实践**

1. 迭代：从高层对问题观察，然后从底层细节对问题观察。在反过来影响高层看问题的角度以进入良性循环。
2. 分而治之：将复杂的问题拆分为多个简单的问题
3. 自上而下和自下而上的方法：有抽象衍生出细节和由细节总结出抽象。

**建立实验性原型**

有时候我们无法准确的判断一种设计方案是否满足需求，比如我们在正式使用前可能无法知晓数据库是否达到性能上的要求。这时可以使用实验性的数据来对目标性能进行测试，如数据量的大小，字段的个数等等。

**合作设计**

与外部或其他人一起讨论软件设计。

**要做多少设计才够**

设计不能做多也不能做少，做多了浪费时间，做少了则会影响开发效率。

这里有几个原则：

1. 团队能力越强，则设计可以越少。
2. 团队能力很强，但却缺乏这个软件的设计经验，则可适当增加设计时间。
3. 项目越是大型，在设计应该越详细。
4. 项目周期越长，则设计应该越详细。
5. 项目的人员变动越多，则设计需要越详细。
6. 项目越重要或要求越安全，则设计需要越详细。

**记录设计的成果**

1. 将设计结果插入到代码中，使用注释或一些其他的手段将设计结果固化在代码中。
2. 用wiki来记录设计讨论和决策
3. 写总结邮件
4. 保留设计原型

# 第六章 可以工作的类

## 6.1 数据抽象类型（Abstract Data Type）

数据抽象类型的定义：可以理解成一个类的内部**成员变量（类属性）**将其进行抽象，使其无法被外部所知悉其内部的细节。将对成员变量的直接修改抽象成通过函数的形式进行间接修改（其实无法知悉是否真的修改了，我们只需要知道通过调用该函数可以达到对应的目的，而无需了解其内部的数据结构或成员变量）。

数据抽象类型（ADTs）的使用场景：将**成员变量（类属性）**通过**函数**进行封装从而隐藏内部的实现，即外部无法通过了解**内部成员变量**的含义来对成员变量做出对应的修改，必须通过**函数**的方式对类属性进行修改

使用数据抽象类型（ADTs）的作用：

1. 可以隐藏细节。
2. 改动不会影响到整个程序。（当多个其他的类同事依赖于数据抽象类型时，只需通过修改对应的函数或方法就可以对整体进行修改）
3. 让函数尽可能的提供更多的信息。
4. 更容易调高性能。（如果需要提供性能只需要提高ADTs对应的函数的性能就可以提高整体的性能）
5. 让程序的正确性更显而易见。
6. 程序将会更有自说明性。
7. 无须再程序内到处传递数据。（通常只需要传递一个类即可将其内部的ADTs进行间接的传递，从而提高了数据的传递效率）
8. 你可以像在现实世界中那样操作实体，而不需要从底层实现上去操作它。

创建ADTs的指导建议：

1. 把常见的底层数据类型创建为ADT并通过ADT提供的函数来使用这些底层数据类型。
2. 把像文件这样的常用对象当作ADT
3. 简单的事物也可以当作ADT
4. 不要让ADT依赖于其存储介质。

通过以上叙述，可以了解到ADTs在面向对象中常见的使用方式是通过访问控制符public、private来进行控制（事实上，我认为protect的继承方式会影响一个类的封装性）。

## 6.2 良好的类接口（Good Class Interfaces）

### 好的抽象（Good Abstract）

一个类所公开出来的类成员函数应该尽可能的展现同一层次的抽象。

好的抽象可以用到的方法：

1. 类的公开的成员函数应尽可能的展示一致的抽象层次。（举例：假设对于一个类的职责是用于操作文件，如果这个类拥有一个文件列表，则不应该公开存储文件列表的List数据结构的成员函数，而是公开操作文件这个类的函数）
2. 一定要理解类所实现的抽象是什么。（即将假设一个类的职责是用于操作文件，则该类的提供的抽象能力不是是操作列表数据结构，如addListItem等操作）
3. 合理的提供成对的服务。（如一个类是将灯进行开/关，则需要同时提供开启和关闭两个公开函数）
4. 把不相关的信息转移到其他的类中
5. 尽可能让接口可编程，而非**表达语义**（表达语义的含义：对于一个公开的方法应该尽可能的不依赖于一些其他的前置条件，如：该类的begin函数必须依赖于init函数的调用才能工作。）。（正如刚刚的例子，由于begin函数必须依赖于init函数才能调用，那么可以在函数的入参添加一个init参数，通过begin本身来调用init函数从而减少**表达语义**。如果函数必须表达语义，则必须让该函数进行相应的检查以确保begin函数调用之前已经调用了init函数）
6. 谨防在修改时破坏接口的抽象。（当对类进行修改或拓展时，常常发现会加入一些本不属于该类的函数。可看上去缺也很难使用另一种方式来实现。[在重构一章中会进行讲解]）
7. 不要添加于接口抽象不一致的公开函数
8. 同时考虑抽象性和内聚性

### 良好的封装

常用的良好封装的方法：

1. 尽可能的限制类和类属性的访问性
2. 不要公开暴露成员数据
3. 不要对类的使用者做出任何假设
4. 避免使用友元类
5. 不要因为一个函数里只使用公开的函数就将其加入到公开的函数中
6. 让阅读代码比编写代码更方便
7. 要格外警惕从语义上破坏封装性
8. 留意过于紧密的耦合

### 有关设计和实现的问题

#### 包含

尽可能的使用“has a”的方式来实现功能的继承，而非使用“is a”的方式。

其主要的注意事项有：

1. 通过包含来实现“has a”的关系。（如：猫可以拥有一双爪子，而非继承的方式来表达猫是一个爪子）
2. 在万不得已时使用私有继承的方式来实现“has a”的关系。（注：很多语言并不支持这种能力）
3. 警惕超过有7个成员变量的类。（这个有待商榷吧）

#### 继承

首先，继承的概念：是一类对另一个类的特化。

使用继承的注意事项：

1. 用公开的继承来实现“is a”的关系
2. 要使用继承并详细进行说明，要么就不要用它
3. 请遵循里氏替换原则（除非子类真的是父类的一个特化，否则不要使用继承）
4. 确保继承需要继承的部分
5. 不要覆盖一个不可覆盖的函数。（如一个父类私有的函数被子类用相同的函数名进行了覆盖）
6. 把公共的接口、数据及操作尽可能的放到继承树中尽可能高的位置。（具体多高算高：当如果该方法所处的继承树位置会破坏该位置的抽象性时，则就应该停下）
7. 只有一个实例的类是值得怀疑的。（单例设计模式除外）
8. 只有一个子类的父类是值得怀疑的。（这里可以描述为不应该做提前的过度设计）
9. 子类覆盖了某个函数后，但在该函数中没有做任何操作，这种情况值得进行怀疑。
10. 避免让继承体系过深。
11. 尽量使用多态，从而减少大量的类型检查。
12. 让所有的数据都是私有的。

**为什么有这么多关于继承的规则：**

因为继承会无形中增加复杂度，而程序最应该控制的就是复杂度的问题。而以下情况则区分了继承和包含的一些用法：

1. 如果多个类共享数据而非共享行为，则应该为这些类创建一个包含公共的数据对象。
2. 如果多个类共享行为而非共享数据，则应该让它们从共同的父类中继承而来，并在父类定义公共的函数。
3. 如果多个类即共享数据又共享行为，则应该让它们从共同的父类中继承而来，并在父类中定义公共的函数以及包含公共的数据对象。
4. 当你想由父类控制接口时，使用继承；当你想自己控制接口时，使用包含。

#### 成员函数和数据成员（类的函数以及类的数据）

实现类的函数以及类的数据时的一些指导建议：

1. 让类中的成员函数尽可能的少
2. 禁止隐式的产生你不需要的成员函数和运算符（即当某些类需要进行隐藏，则应该将其设置为私有的类。使其无法从外部直接进行创建）
3. 减少类所调用的不同函数的数量
4. 对其他类的函数的间接调用要尽可能少（如：A对象->B对象->C对象->执行（A，B，C对象都被耦合在了一起），这种应该尽可能的避免。这样的好处是尽可能的使类与类之间解耦。）
5. 一般来说，应该减小类和类之间相互合作的范围

#### 构造函数

关于构造函数的指导意见：

1. 如果可能，应该在所有的构造函数中初始化所有的数据成员
2. 用私有构造函数来强制实现单例设计模式
3. 优先采用深拷贝，除非论证可行，才采用浅拷贝。（采用深拷贝可以确保数据的安全性，而浅拷贝主要考虑的则是性能问题。而对于未来未可知的性能问题，应该优先考虑安全性问题）

### 创建类的原因

可能我们认为创建类的原因是为了对物理世界的事物建立对应的模型。则事实上，原因远不止如此。下面就列举一些创建类的原因：

1. 为现实世界中的对象建模。
2. 为抽象的对象建模。（如：形状、颜色、进制转换等抽象概念）
3. 降低复杂度。（创建一个类后可以将细节隐藏在内部，从而使外部无需了解内部细节以减少复杂度）
4. 隔离复杂度。（即当一个类出错后可以将复杂的错误保留在类的内部从隔离复杂度）
5. 隐藏实现细节。
6. 限制变动的影响范围。
7. 隐藏全局数据。
8. 让参数传递更顺畅。（传递一个类比传递多个参数会更好，并且新增的参数如果保留在类中，则无需改动函数的声明）
9. 建立中心控制点。（即可以在一个类中控制某一项任务，从而将所有操作都保留在类中，）
10. 让代码更易于重用（即这个类如果是通用的类，则可以在其他的地方也派上用场）
11. 把相关操作放到一起。（如将计算三角函数的函数包装到一个类中）
12. 实现某种特定的重构。

#### 应该避免的类

1. 避免创建万能类。（即一个类需要有明确的功能）
2. 消除无关性要的类。（一个类如果只包含数据而不包含行为，则它应该考虑它是否是一个真正的类）
3. 避免用动词命名的类。（一个类如果使用了动词进行修饰，则应该考虑这个类是否可以转换为函数）

### 比类更大的范围概念：包（package）

包是一个比类更为抽象的概念，其抽象能力将比类更加强大。其功能是类更进一步的进行归类。

### 关键点

* 类的接口应该提供一直的抽象。
* 类的接口应该隐藏一些信息。
* 包含往往比继承更为可取。
* 继承是一种有用的工具，但它却会增加复杂度，这有悖于软件首要技术使命——管理复杂度。
* 类是管理复杂度的首要工具。要在设计类时给予足够的关注，才能实现这一目标。

# 第七章 高质量的子程序

问题1:什么是子程序?

子程序是为了实现一个特定的目的而编写的一个可以被调用的方法、函数、宏等。

一个低质量的子程序一般会出现的问题：

1. 这个子程序的命名很差。
2. 这个子程序没有对应的文档。
3. 这个子程序没有良好的布局。或没有统一一个风格。
4. 如果一个入参是不可修改的要么用const进行修饰，要么采用值传递，要么进行必要的说明。
5. 一个子程序读取的全局变量。
6. 一个子程序没有单一的目的。即一个子程序只完成一件事。
7. 子程序没有注意防范错误数据。
8. 一个子程序读取了若干的魔数（magic number）
9. 一个子程序中未使用所有的参数
10. 参数的传递方式有误
11. 一个子程序有太多的参数
12. 一个子程序的参数顺序混乱且没有进行注释

## 7.1 创建子程序的正当理由

1. 降低复杂度。（使用子程序将复杂度隐藏在子程序的内部，从而在外部无需关心其内部的复杂度）
2. 引入中间、易懂的抽象。（如写了一个遍历数据的代码段，则可以将其转换为遍历数据的子程序并进行相应的命名，从而提供了更高层次的抽象）
3. 避免代码重复。
4. 支持子类化。（覆盖简短的子程序比覆盖冗长的子程序要方便的多）
5. 隐藏顺序。（将程序的语义隐藏在子程序中从而降低复杂度）
6. 隐藏指针操作。
7. 提高可移植性。
8. 简化复杂的布尔判断。（通过子程序将布尔判断进行包装提高可读性）
9. 更容易改善性能。（可以通过一个地方的代码优化提高整体的运行效率）
10. 确保所有的子程序都很小。（这个有点瞎扯，有些时候一个长的子程序会更好）

### 似乎过于简单而没必要写成子程序的操作

一个过于简单的操作也可能逐渐演变成一个复杂的操作，如果采用了子程序的方式进行操作，则可以只修改子程序从而完成所有地方的修改。

小贴士：很多创建类的正当理由也是创建子程序的正当理由

## 7.2 在子程序层上设计

封装和抽象是内聚性这个概念的具体体现。封装和抽象一般是体现在类上的内聚性，而在子程序的这个层次上，则有另一种内聚性的体现。

程序内聚性指的是各个子程序相互依赖的紧密程度。对于一个子程序如果依赖的外部子程序越少，则内聚性越强。所以我们的目标是让一个子程序只把一件事做好，而不再做任何其他的事情。

以下有几个内聚性的层次概念：

1. 功能的内聚性。（这种内聚性最强也是最好的，让一个子程序只执行一项操作。不过前提是子程序执行的操作和其命名相符：若这个子程序还做了其他操作则它不够内聚，并且命名也存在问题）
2. 顺序内聚性。（指的是在子程序中要包含特定顺序执行的操作，需要在全部执行完成后才能完成完整功能）
3. 通讯上的内聚性。（指在一个子程序的不同操作使用了相同的数据。但不同的操作本身没有任何联系）
4. 临时内聚性。（指一些原因需要放到一起执行的操作。这种内聚性认为是不可取的，因为这个子程序本身违背了一个子程序只做一件事情的原则，好的方式应该是将内部的多个不同的操作转为多个子程序，并由原来的子程序进行调用完成）

下面是一些不可取的内聚性：

1. 过程上的内聚性：指一个子程序中的操作是按特定顺序进行的。

2. 逻辑上的内聚性：指将若干操作放入到同一个子程序中，然后通过传入标志位来执行某一项操作。这样将会导致子程序充斥着大量的条件判断语句（当然如果一个子程序中只包含判断语句也是可行的）。

3. 巧合的内聚性：指子程序中的各个操作之间没有任何可以看到的关联。这种纯粹的巧合内聚性很难转换为更好的内聚性。

## 7.3 好的子程序名称

好的子程序名称能够清晰的描述子程序的功能。

1. 描述子程序所做的所有事情。
2. 避免所有无意义的、模糊或表述不清的动词。
3. 不要仅通过数字来形成不同的子程序名称。
4. 根据需要确定子程序名字的长度。
5. 给函数命名时要对返回值有所描述。
6. 给过程取名时使用强烈的动词加宾语形式。（如：printDocument等）
7. 使用准确的对仗词。（如：get/set，begin/end等）
8. 对常用操作建立命名规则。（如：对id、ID、Id等建立对应的命名规则）

## 7.4 子程序可以写多长

理论上认为的子程序长度一般是在50行-150行之间。通常子程序最好不要超过200行。但是也会存在一些较长的子程序。

## 7.5 如何使用子程序的参数

一个子程序的参数可以按照某些指导来进行规范：

1. 按照输入-修改-输出的顺序排列参数。
2. 考虑以下in和out的关键参数名称。
3. 如果几个子程序都用了类似的一些参数，应该让这些参数排列顺序保持一致。
4. 请使用所有的参数。
5. 把状态、标志或出错变量放到最后。
6. 不要把子程序的参数当成子程序中的变量来使用。
7. 把子程序的参数个数限制在7个之内。（如果一个子程序需要传递过多的变量，应该考虑是否子程序之间的耦合度过高）
8. 考虑对参数采用某种表示输入、修改、输出的命名规则。
9. 为子程序传递用以维持其接口抽象的变量或对象。（对于一个对象参数，我们应该确保对象参数中被调用的子程序不会破坏原有的接口抽象，这里实用的一种方法是将对象参数抽象为一个接口参数interface，以确保子程序的接口抽象不会被破坏）
10. 使用具名参数类型。而非使用通用参数类型如：int，float等参数。（好处是：可以让编译器帮你检查参数的传入是否有问题）
11. 确保实际参数和形式参数匹配。（例如对实际数据进行强制转换以匹配形式参数，这种情况应该要确保转换后的数据不会发生改变或是符合预期）

## 7.6 对于没有返回值的“函数”本质是一个“过程”

### 什么时候使用函数？什么时候使用过程？

一言以蔽之，如果一个子程序的主要用途是返回由其名字所指明的返回值，那么应该使用函数，否则使用过程。

### 设置函数的返回值

使用函数时总存在返回不正确的返回值的风险，当有多个可能的返回路径时，而其中一条路径没有返回值，则会会发生错误，为了减少这种错误的发生，可以有以下建议：

1. 检查所有可能的返回路径
2. 不要返回指向局部数据的引用或指针。（主要针对手动分配内存的语言）

# 第八章 防御式编程

防御式编程的主要思想是：子程序不应该因为传入错误的参数而被破坏，哪怕是由其他子程序产生的错误数据。更一般的的说，其核心思想是要承认程序都会有问题，都需要被修改。

## 8.1 保护程序免遭非法输入数据的破坏

对于错误的数据输入，我们应该做到：“垃圾进，什么都不出”，“垃圾进，出来错误提示”，“不许垃圾进来”。这样才能保护程序不会被非法数据所破坏。

通常有三种方法来处理这些非法数据：

1. 检查所有来源于外部的数据的值。（这种数据包括内部调用其他子程序后获取的值）
2. 检查子程序输入参数的值。
3. 决定如何处理错误的输入参数。

## 8.2 断言

断言是指：在开发期间（所以断言一般不会出现在生产环境中）使用的、让程序在运行时进行自检的代码。如果断言为真，则表明程序正常，而断言为假，则意味着程序出现了意料之外的错误。

### 使用断言的指导建议

下面是一些使用断言的指导建议：

1. 用错误代码来处理预期会发生的状况，用断言来处理绝不应该发生的状况。（可以理解成断言是用来检查代码中的bug的。）
2. 避免把需要执行的代码放到断言中。
3. 用断言来注解并验证前条件和后条件。（前条件：用于在调用其他子程序时，确保调用的数据的正确性；后条件：调用子程序后确保结果的正确性）
   4. 对于高健壮性的代码，应该先使用断言再处理错误。（断言是在测试的时候使用，而处理错误保证在正式使用时对数据的保证）

## 8.3 错误处理技术

​	断言是用于处理代码中不应该发生的错误。而对于预料中的错误可以使用错误处理技术。对于错误处理技术可以通过以下的一些技术进行使用：

1. 返回一个没有危害的中立值。（如返回0，返回空指针等）
2. 返回下一个正确的数据。
3. 返回与上次相同的数据。
4. 换用最接近的合法值。
5. 把警告信息记录到日志中。
6. 返回一个错误码。
7. 调用错误处理程序或错误处理对象。
8. 当错误发生时显示错误信息。
9. 用最稳妥的方式在局部处理错误。
10. 关闭程序。（当检测到错误关闭程序应该用于性命攸关的应用程序。因为一个错误可能导致不可估量的后果，此时关闭程序也许是个好方法）

### 健壮性与正确性

​	对于错误处理，有时候需要更注重于**健壮性**，有时候需要更注重于**正确性**。

* 正确性：意味着永远不会返回不准确的结果。
* 健壮性：意味着要不断的采取某些措施来保证软件的正常运行，哪怕有时候会得到一些不正确的结果。

在不同的软件使用场景可能需要注重的点会不相同。

### 高层次设计对错误处理的影响

由于错误处理有太多不同的方式来执行，所以需要采用一套一致的处理方式对错误进行处理（并且我理解需要保证错误的处理需要在合适的地方进行处理以避免错误的失真；相当于错误的发生地与错误的处理地已经发生了严重偏离，比如错误在 color 中发生，却在 car 中对错误进行了处理）。比如低层次的代码只报告错误，那么就需要统一在高层次的代码中对错误进行处理。

## 8.4 异常

异常是把代码中的错误或异常事件传递给调用法代码的一种特殊的手段。如果在一个子程序中遭遇了意料之外的错误并且不知道该如何处理时，则可以抛出一个异常。并且异常也可以用于清理一些杂乱的逻辑。

**注意：对于异常，我们应该和对于继承一样，保持一个谨慎的态度对待。明智的使用，可以降低代码复杂度，而滥用则反而会使代码难以理解，**

以下是一些异常使用的一些指导建议：

1. 用异常通知程序的其他部分，发生了不可忽略的错误。（所以对于捕获异常的程序，一定要对异常进行处理。而不是单纯进行捕获）
2. 只有在真正例外的情况下才抛出异常。（异常应该和断言类似，只有在真正意外的情况下才进行处理；并且异常机制会破坏类的封装性，强制让你了解其内部细节以及如何处理这种内部异常。这种无形中会增加代码的复杂度。而软件设计的首要目标就是**管理复杂度**）
3. 不能用异常来推卸责任。（如果某种错误可以在局部处理，就应该在局部处理掉。而不是将这个错误当成一个异常抛出去）
4. 避免在构造函数和析构函数中抛出异常，除非你在同一个地方把它们捕获。（这种在构造函数或者析构函数抛出异常，会额外出现一些问题；从而增加智力负担，我们应该尽可能的管理复杂度）
5. 在恰当的抽象层次抛出异常。（对于一个函数抛出的异常应该符合这个函数或者这个类的描述，而不是抛出一个与这个函数或者这个类不相关的异常，比如：Time 类的抛出了一个 IOException 异常；这种抛出异常的方式让调用方强制了解了其内部的细节从而破坏了封装性，我们应该将 IOException 异常改造成 TImeNotAvailable 以异常内部细节病提供统一的接口抽象。）
6. 在异常信息中加入导致异常发生的所有信息。
7. 了解所用函数库可能抛出的异常。
8. 考虑创建一个集中的异常报告机制。
9. 考虑异常的替代方案。
10. 把项目中对异常使用标准化。（如：规定异常的使用场合、规定是否允许构造函数或析构函数使用异常、规定对异常的信息标准化、确定是否使用集中异常处理机制、考虑创建项目的特定异常类，它可用于做为项目异常的基类用于规范日志记录、报错错误等。）

## 8.5 隔离程序：包容错误造成的损害

隔栏（barricade）是一种容损策略。它的主要作用是为了将错误进行隔离，使之不会将破坏扩散。

以防御式编程为目的的一种隔离方法：将某些接口选定为“安全”区域的边界。对穿越安全区域边界的数据进行合法性校验。

根据上述的隔离方法。**对于类而言，我们可以将类公开的方法设置为“安全”区域的边界，公开的方法需要对数据进行安全性检查，而一旦数据通过公开方法的安全性检查时，那么类的私有方法就可以假定数据都是安全的**。

### 隔栏和断言的关系

隔栏使断言和错误处理有了明显的区分，隔栏外部的程序应使用错误处理技术，在那里对数据做的任何假设都是不安全的。而在隔栏的内部就应该使用断言技术。因为传入的数据已经被隔栏清理过了。如果隔栏内的某个子程序检查到了错误的数据，那这应该是程序的错误，而非数据的错误。

## 8.6 辅助调试代码

防御式编程的另一个重要的手段是**辅助调试代码**。使用得当，可以快速检测错误。

### 不要自动地把产品版的限制强加于开发版上

我们应该在开发期间牺牲一些软件的速度和资源的使用，来换取一些可以让开发更顺畅的内置工具。

### 尽早引入辅助代码

越早引入辅助代码，它能够提供的帮助也会越大。对于引入辅助代码，可以在项目中自始自终帮助你。

### 采用进攻式编程

进攻式编程：	在开发阶段让他显现出来，而在产品运行时让它能够自动恢复。

下面是进攻式编程的一些方法：

1. 确保断言语句使程序终止。在开发阶段引起的麻烦越大越好，这样它才能被修复。
2. 完全填充分配到的内存，这样才能让你检测到内存错误。
3. 完全填充已分配到的所有文件或流，这样才能让你排查出文件的错误。
4. 确保每个 case 语句的 default 分支或者 else 分支都能产生严重的错误或至少让这些错误不能被忽视。
5. 在删除一个对象前把它塞满垃圾数据。

### 计划移除调试辅助的代码

我们应该有计划的在发布产品的时候移除对应的调试代码。

下面是一些可以采用的方法：

1. 使用类似 ant 或 make 的工具
2. 使用内置的预编译器
3. 编写自己的预编译器

## 8.7 确定在产品代码中该保留都是防御式代码

防御式编程存在一种矛盾的观念；即在开发阶段你希望错误能引人注意，但在产品阶段，你却想让错误尽可能的偃旗息鼓，让程序能十分稳妥地恢复毁停止。下面给出一些指导意见来处理这种矛盾：

1. 保留那些检查重要错误的代码
2. 去掉检查细微错误的代码
3. 去掉可以导致程序崩溃的代码
4. 保留可以让程序稳妥地崩溃的代码
5. 为你的技术支持人员记录错误信息
6. 确定留在代码中的错误信息是友好的



## 8.8 对防御式编程采取防御的姿态

过度的防御式编程也会引发问题，如果在每一处能想到的地方用每一种能想到的方法检查参数，那么程序会变的臃肿而缓慢。并且防御式编程会引入额外的代码导致程序变的更加复杂。并且更可怕的是，你不能确定引入的防御式代码是没问题缺陷的。因此应该好好考虑如何使用防御式编程。

# 第九章 伪代码编程过程

本章描述了伪代码编程过程，这种编程过程有助于减少设计和编写文档所需的工作量，并可以同时提高二者的质量。

伪代码编程过程并不是创建类或程序的唯一过程。还有一些其他流行的方法：测试先行开发、契约式设计等。

## 9.1 创建类和子程序的步骤概述

创建一个类可以有多种方式，但一般而言都是一个迭代过程。通过先对一个类做总体设计，再为类的内部的特定子程序进行设计与创建，并检查设计的结果反复迭代。

### 创建一个类的步骤

创建一个类的关键步骤如下：

1. 创建类的总体设计。（定义一个类的指责，需要隐藏的细节，精准的定义其所代表的抽象，设计公开的方法，反复迭代直到能够直截了当设计出子程序为止）
2. 创建类中的子程序。
3. 复审并测试整个类。（完成后需要对类进行复查与测试）

### 创建子程序的步骤

一个类的大部分子程序都是简单、直截了当的。而有一些子程序却比较复杂，因此也会采取更加系统化的方法进行设计，包括：设计子程序、检查设计、编写子程序代码、检查代码。

专家们已经开发出很多创建子程序的方法，下面需要介绍**伪代码编程过程** 。

## 9.2 伪代码

“伪代码”这个术语是指某种用来描述算法、子程序、类或完整程序的工作逻辑的、非形式的、类似于英语的记法。伪代码编程过程则是一种通过书写伪代码而更高效地创建程序代码的专门方法。

由于伪代码看起来很像英语，所以很可能自然而然的认为，任何可以用来收集想法的类似英语的描述，都能起到大同小异的作用。而实践中则会发现，某些形式的伪代码比其他形式的更有用。下面是有效使用伪代码的指导原则。

1. 用类似英语的语句来精确描述特定的操作。
2. 避免使用目标语言特有的语法元素。（这样做的目的是将伪代码能够在高于代码层次上进行设计，从而让其不依赖于某种特定的语言）
3. 在意图的层面上编写伪代码。用伪代码描述解决问题的方法的意图，而不是去写如何在目标语言中实现该方法。
4. 在一个足够低的层次编写伪代码，以便近乎自动的生成代码。（如果伪代码层次太高，则会掩盖代码的问题细节。你应该不断精华伪代码，加入越来越多的细节，直到看起来很容易直接写出代码为止）

伪代码一经写好，就可以按照伪代码的意图去生成实现代码，同时伪代码会变成编程语言中的注释，这样就节省了大部分注释工作。

## 9.3 通过伪代码编程过程创建子程序

本节将描述如下与创建子程序有关的活动。

1. 设计子程序
2. 编写子程序的代码
3. 检查代码
4. 收尾工作
5. 按照需要重复上述步骤

### 设计子程序

对于设计子程序的一些建议：

1. 检查先决条件。（在动手前检查这个子程序是否真的需要，是否与整体设计相匹配，子程序的工作是否已经在需求上定义好了）
2. 定义子程序要解决的问题。（描述子程序将要解决的问题，并且要描述要足够详细，以便能去创建这个子程序。而这个详细说明应该包含如下）
   1. 这个子程序将要隐藏的信息
   2. 传给这个子程序的输入。
   3. 这个子程序的输出。
   4. 在调用子程序之前确保有关的前条件成立。（如文件已被打开）
   5. 在子程序将控制权交还给调用方时，确保后条件成立。（如文件已被关闭）
3. 为子程序命名。（可参考 7.4 好的子程序名称）
4. 决定如何测试子程序。
5. 在依赖库中搜寻可用的功能。
6. 考虑错误处理。
7. 考虑效率问题。
8. 研究算法和数据类型。
9. 编写伪代码。
10. 考虑数据。
11. 检查伪代码。
12. 在伪代码中试验一些想法，留下最好的想法。

### 编写子程序代码

一旦一个子程序已经设计好，就能够通过近乎标准化的顺序来实现子程序。大致的步骤：

1. 写出子程序声明。
2. 编写第一条和最后一条语句。
3. 在每条注释下填充代码。
4. 检查代码是否需要进一步分解。
5. 收尾工作。

### 检查代码

当实现了一个子程序之后，就是要检查之前所构建的代码是否正确。如果在这一阶段的错误都留到测试阶段才能发现。那到时候再排查和修正这些错误代价会更加的昂贵。

1. 在脑海里检查程序中的错误。
2. 编译子程序。
3. 在调试器中逐行执行代码。
4. 测试代码。
5. 消除程序中的错误。

### 收尾工作

检查完错误后，参考优秀代码得特性来检查代码。

1. 检查子程序的参数。
2. 检查整体的设计质量。
3. 检查子程序中的变量。
4. 检查子程序的语句和逻辑。
5. 检查子程序的布局。
6. 检查子程序的文档。
7. 除去冗余的注释。

### 最后根据需要重复上述步骤

## 9.4 伪代码编程过程的替代方案

下面是一些伪代码编程过程的补充或是替代方案。

1. 测试先行开发
2. 重构
3. 契约式设计
4. 东拼西凑

# 第十章 使用变量的一般事项

## 10.1 数据认知

创建有效数据的第一步是了解要创建数据的种类。

### 数据认知测试

下面把熟悉的概念写 1，知道其含义但却不确定的概念写 0.5。写完后把总分加起来，然后统计分数用后面的解释分数来了解所代表的含义。

—— 抽象数据类型 ( abstarct data type )		—— 文字量 ( literal )

—— 数组 ( array )												—— 局部变量 ( local variable )

—— 位图 ( bit map )											—— 查找表 ( lookup table )

—— 布尔变量 ( boolean variable )					—— 数据成员 ( member data )

—— B-树 ( B-tree )											   —— 指针 ( point )

—— 字符变量 ( character variable )				  —— 私有 ( private )

—— 容器类 ( container class )							—— retroactive synapse

—— 双精度 ( double )										   —— 完整引用 ( referential integrity )

—— elongated stream										  —— 栈 ( stack )

—— 枚举类型 ( enumerated type )					—— 字符串 ( string )

—— 浮点 ( floating point )								  —— 结构变量 ( structured variable )

—— 堆 ( heap )													  —— 树 ( tree )

—— 下标 ( index )												—— typedef

—— 整数 ( integer )											 —— 联合体 ( union )

—— 链表 ( linked list )										—— value chain

—— 具名变量 ( named constant )					—— 变体 ( variant )

——  总分

评分参考:

0 - 4: 你是一个写程序的新手。

15 - 19: 中级程序员的水平 。

20 - 24: 高级程序员水平。

25- 29: 知道的数据类型很多。( 可以出书了 ^_^ )

30 -32: 没有说真话。( 因为有一部分的变量是杜撰出来的 )



## 10.2 轻松掌握变量定义

本节将讲述如何快速定义变量。（可能会觉得定义变量很简单。然而，创建变量的确会占用大量的时间）

### 隐式声明

有些语言支持隐式声明变量。即不需要提前声明变量就使用该变量而不会报任何错误。

隐式变量对于任何语言都是相当危险的特性：因为当你认为 ID 的值为什么不正确的时候，其实你可能是使用了 Id 变量获取值，而又误认为 ID 获取到了对应的值。( 这种错误很低级，但却很难发现 )

对于支持隐式声明的编程语言下面有一些建议：

1. 关闭隐式声明。
2. 声明全部的变量。
3. 遵循某种命名规则。
4. 检测变量名。

## 10.3 变量初始化原则

不合理地初始化数据是产生编程错误的常见根源之一。

不恰当的变量初始化会导致一系列的问题：

* 变量值过期。
* 变量一部分被赋值。
* 从未对变量赋值。

下面给出一些避免产生初始化错误的建议：

1. 在声明变量的时候初始化。
2. 在靠近变量第一次使用的位置进行初始化。
3. 理想情况下，在靠近第一次使用变量的位置声明和定义该变量。
4. 在可能的情况下使用 final 或者 const。
5. 特别注意计数器和累加器。
6. 在类的构造函数里初始化该类的成员变量。
7. 检查是否需要重新初始化。
8. 一次性初始化**具名常量**：用可执行代码来初始化变量。
9. 使用编译器设置来自动初始化所有变量。
10. 利用编译器的警告。
11. 检查输入参数的合法性。
12. 使用内存访问检查工具来检查错误的指针。
13. 在程序开始时初始化工作内存。

## 10.4 作用域

“作用域” 可以看作是衡量变量知名度的方法：它的知名度有多大？作用域指的是变量在程序内的可见和可引用的范围。

在早期的编程语言中，所有的变量都是全局的。因此会带来很多问题。

下面是一些使用作用域的规则。

### 使变量引用集中化

那些介于同一个变量多个引用点之间的代码成为“攻击窗口”。可能会有新代码加到这个窗口中，不当的修改了这个变量，或者阅读代码的人可能会忘记该变量应有的值。

一般来说，把对一个变量的引用尽可能集中化是一种好的方法。

衡量一个变量的集中度叫做“跨度( span )”

举个例子：

``` 
a = 0;
b = 0;
c = 0;
a = b + c;
c = c + 1;
c = c + a;
```

这个例子中，对 a 的第一次引用和第二次引用存在 2 行代码，因此 a 这个变量的跨度为 2。而 c 的第一次引用和第二次引用存在 1 行代码，第二次引用和第三次引用存在 0 行代码，所有总跨度是 1，而平均跨度是 0.5。

把变量的引用点集中起来的主要好处是提高可读性。

### 尽可能缩短变量的“存活”时间

与变量跨度相关的一个概念是“存活时间”，即一个变量存在期间所跨越的代码总数。变量的存活开始于第一次引用语句，结束于最后一次引用语句。

与跨度不同的是，存活时间不受第一次和最后一次引用之间变量的使用次数影响。

还是上面的例子，对于 a 变量，它的存活时间是 4 行代码；其平均跨度是 2。对于 c 变量，他的存活时间也是 4 行代码，其平均跨度是 0.5。

与跨度类似，保持较低的存活时间也是我们的目标，应使得对象的存活时间尽可能的短。这样的好处有：

1. 降低变量被错误或无意义修改的可能性。
2. 使你对自己的代码有更准确的认识。
3. 减少初始化错误的可能。
4. 使代码更具有可读性。
5. 短的变量存活时间可以更容易将大的子程序拆分为小的子程序。

#### 测量变量的生存时间

还是刚刚个上面的例子：

* a 的生存时间：6 行
* b 的生存时间：3 行
* c 的生存时间：4 行
* 所有变量的平均生存时间为： （6 + 3 + 4） / 3 约等于 5 行。

虽然无法定量的通过分析变量的跨度和存活时间来区分好坏与优劣。不过可以肯定的是通过减小跨度和存活时间是个好的选择。

如果用跨度和存活时间的概念来考量全局变量，就会发现全局变量的跨度和存活时间很长——这也是避免使用全局变量的好理由之一。

## 减小作用域的一般原则

下面是一些减小作用域的一般原则：

1. 在循环开始之前再去初始化该循环里使用的变量，而不是在该循环所属的子程序的开始处初始化这些变量。
2. 直到变量即将被使用时再为其赋值。
3. 把相关语句放到一起。
4. 把相关语句组提取成单独的子程序。
5. 开始时采用最严格的可见性，然后根据需要拓展变量的作用域。

## 有关缩小变量作用域的说明

程序员采用哪种缩小变量作用域的方法取决于如何看待“方便性”和“智力上的可管理性”。

“方便性”和“智力上的可管理性”两种理念的区别，根本在于侧重是写程序和读程序的区别。使作用域最大化可能真的会让写程序更方便，当相对于子程序功能划分明确的程序，一个允许任何子程序在任何时间使用任何变量的程序是更难于理解的。对于这种程序，你不能只去理解一个子程序；你还必须理解其他所有使用了相同全局变量的子程序才行。这种程序无论是阅读还是调试修改都非常困难。
