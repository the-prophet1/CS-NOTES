# 第二章 用隐喻来更充分的理解软件开发

1. 隐喻的重要性：隐喻即是类比。
2. 隐喻不会告诉我们答案在哪里，而是告诉我们如何寻找答案：隐喻不是算法，具有不确定性。隐喻只能给你大致的思考方向；甚至可能是错的。

# 第三章 前期准备

## 问题定义的先决条件

问题定义： 只定义问题是什么？而不是定义问题的解决方案。

如：我们快无法完成订单了。而不是：我们需要优化系统，使我们完成订单。

问题定义应该尽可能的使用客户的语言去描述问题。

**未能定义问题**带来的后果：花费大量时间去解决错误的问题。

## 架构的典型组成成分

设计架构图：应将各个模块的责任分析清楚，并明确定义各个模块的功能，使各个模块对其他模块的了解达到最小。并明确描述模块之间能否**直接使用、间接使用、无法使用**。

主要的类：应该将各个类的责任和交互进行描述，包含：状态转换、持久化、继承体系等。并记述曾经考虑过的其他类设计方案。

数据设计：描述主要文件和数据表的设计。并将为何这样设计的原因以及为什么没有选其他方案的原因进行解释。并解释为何使用不同的数据存储组件或架构，如：为何使用单数据库（或多数据库）、为何使用缓存（redis）等。

业务规则：如果架构依赖与特定的业务规则。那就应该详细的描述这些业务规则对架构的影响。

资源管理：架构应该描述管理稀缺资源的计划。如数据库连接数量、线程数量、内存量等。架构应该可以估算出正常和极限情况下的资源使用量。

安全性：对应有的访问权限的控制的设计，以及配置文件和cookie等数据的访问控制。

性能：评估出性能目标，以及达到性能的目标的预期资源使用。并指出为什么可以达到性能预期；以及使用了哪些特定的算法和数据结构来优化性能也应该进行描述。

可伸缩性：对系统增长以满足未来需求的能力。架构应该描述系统如何应对用户数量、服务器数量、网络节点数量、数据记录数量的增长。

错误处理：

* 对错误进行纠错还是检测：如果是纠错就应该尝试从错误中恢复过来。如果是检测则就当“无事发生”一样继续执行接下来的操作或者退出。但无论是哪一种情况，都应该进行记录并通知。
* 错误检测是主动的还是被动的：例如主动检测用户的输入信息，或被动的当数据发生错误时进行被动的错误处理。但无论是哪一种情况，都会对界面造成一定的影响。
* 程序应该如何传递错误：程序一旦检测到错误的数据，可以立刻丢弃引发错误的数据。也可以把这个错误数据当成一个错误，并进入错误处理状态。或可以将错误的数据暂存下来，并在处理完成后，在通知用户错误的位置。
* 错误处理的信息有什么约定：架构应该制定一套错误规范。保证所有错误都在该规范中进行处理。
* 如何处理异常：架构应该规定代码何时可以抛出异常，在什么地方进行异常的捕获。如何记录异常，以及如何描述异常。
* 在程序中，在什么层次上处理错误：1. 在发现错误的地方处理错误。2. 调用专门的错误处理类对错误进行处理。3. 沿着调用链将错误向上传递。
* 每个类在验证其输入数据的有效性方面应该有什么责任：每个类自己验证自己的数据有效性还是有一组验证器来验证数据的有效性。能否在某个层次上认为默认数据是正确的。
* 应该使用内建的错误处理机制还是使用某种特定的错误处理方法。

容错性：架构应该详细定义所期望的容错种类。包含：错误检测以及错误恢复。当错误无法修复时，则应该包容错误。

架构的可行性：架构应该论证系统的技术可行性。如果任何一个方面不可行会导致项目无法实施。那么架构应该说明如何解决这方面的问题。

过度工程：应该对不同的模块的健壮性规定不同的级别。对于某些无关紧要的模块可以进行简单的设计，而对于重要的模块则需要进行过度设计来保证其健壮性。

“买”还是“造”的决策：当架构需要用到某些组件，而这些组件是可以购买或直接使用的。则应该说明自己定制的组件应该在哪方面胜过现有的组件或程序。

关于复用的决策：如果架构中使用了已存在的工具或组件。应该说明当需要对复用的软件进行拓展时，如何对复用的软件进行加工以满足需求。

更变策略：架构应该提供一定的更变灵活性。并描述考虑过的有可能更变的原因。并说明“最有可能更变的功能也是最容易实现的”。架构应该指出动态绑定数据所用到的策略。如将数据保存在外部文件，而非硬编码。这样就可以在不更变代码的前提下修改程序的功能。

架构总体质量：优秀的架构说明书，讨论了系统的模块背后的隐藏信息、讨论了”采用或排斥所有可能设计替代方案的“的根本原因。

架构的顶层设计：应该独立于特定语言或机器。

# 第五章 软件构建中的设计

**重中之重：对于系统层的软件设计图应该是无环图。即：模块A->模块B->模块C。而不能是:模块A->模块B->模块C->模块A。**

**常见的子系统/模块：业务规则子系统/模块，用户界面子系统/模块，数据库访问子系统/模块，依赖操作系统的子系统/模块**

**找出现实中的对象**：通过理解现实中的对象来刻画系统中的对象应该是什么样子的，包含：共有方法，私有方法，成员变量。

**抽象能力非常重要！**

**封装用以实现抽象后的细节**

**信息隐藏对应设计非常有帮助**

**找到容易改变的区域并将其限制在一个子系统中，而不是分布在各个位置，常见的有：**

1. 业务规则
2. 对硬件和操作系统的依赖
3. 输入和输出
4. 状态变量

**耦合标准的定义：**

1. 调用方与被调用方的参数传递越少则耦合关系越松散
2. 被调用方的共有方法越少则耦合关系越松散
3. 调用方与被调用方的使用全局数据进行信息的交互与参数传递进行信息交互，参数传递的耦合关系更为松散
4. 一个模块越容易被其他模块调用，则耦合关系越松散

**常见的耦合种类:**

1. 简单数据参数耦合：当传递的参数是简单数据类型时，这个耦合关系是正常的。
2. 简单对象耦合：如果一个模块持有一个实例化的对象，那这种属于简单对象耦合，这种耦合关系是不错的。
3. 对象参数耦合：当A传递传递参数给B的参数是对象C，则相比于简单数据参数耦合，这种耦合更为紧密。
4. 语义上的耦合：

   * 当A传递一个标志位给B来执行对应的操作，则A需要了解B中的细节才能传递对应的标志位。如果需要这样做则应该将标志位设置为枚举值或对象。

   * 当A需要使用B时，需要先调用B的init才能使用B，则存在语义上的耦合。

   * 当A需要修改B的全局变量，则需要A先确定修改的结果是否符合预期，这种也存在语义上的耦合。

   * 当A将C传给B进行初始化，而B只对C进行部分初始化以满足A的需求。这种也是语义上的耦合。

   * 当A将抽象类C传给B，而B知道C的实际实现类D，则B将C强转为D并使用D特有的功能进行处理，这种也存在语义上的耦合。

     * 语义上的耦合非常的危险，因为更改被调用模块的代码可能会破坏调用它的模块。并且破坏的方式编译器完全无法检测。

**其他启发式方法**

1. 高内聚性
2. 项目构造分层架构
3. 严格描述类的职责
4. 分配职责
5. 为测试而设计
6. 避免失误
7. 有意识的选择绑定时间
8. 创建中心控制点
9. 考虑使用蛮力
10. 画图
11. 保持设计的模块化

**设计实践**

1. 迭代：从高层对问题观察，然后从底层细节对问题观察。在反过来影响高层看问题的角度以进入良性循环。
2. 分而治之：将复杂的问题拆分为多个简单的问题
3. 自上而下和自下而上的方法：有抽象衍生出细节和由细节总结出抽象。

**建立实验性原型**

有时候我们无法准确的判断一种设计方案是否满足需求，比如我们在正式使用前可能无法知晓数据库是否达到性能上的要求。这时可以使用实验性的数据来对目标性能进行测试，如数据量的大小，字段的个数等等。

**合作设计**

与外部或其他人一起讨论软件设计。

**要做多少设计才够**

设计不能做多也不能做少，做多了浪费时间，做少了则会影响开发效率。

这里有几个原则：

1. 团队能力越强，则设计可以越少。
2. 团队能力很强，但却缺乏这个软件的设计经验，则可适当增加设计时间。
3. 项目越是大型，在设计应该越详细。
4. 项目周期越长，则设计应该越详细。
5. 项目的人员变动越多，则设计需要越详细。
6. 项目越重要或要求越安全，则设计需要越详细。

**记录设计的成果**

1. 将设计结果插入到代码中，使用注释或一些其他的手段将设计结果固化在代码中。
2. 用wiki来记录设计讨论和决策
3. 写总结邮件
4. 保留设计原型

# 第六章 可以工作的类

## 6.1 数据抽象类型（Abstract Data Type）

数据抽象类型的定义：可以理解成一个类的内部**成员变量（类属性）**将其进行抽象，使其无法被外部所知悉其内部的细节。将对成员变量的直接修改抽象成通过函数的形式进行间接修改（其实无法知悉是否真的修改了，我们只需要知道通过调用该函数可以达到对应的目的，而无需了解其内部的数据结构或成员变量）。

数据抽象类型（ADTs）的使用场景：将**成员变量（类属性）**通过**函数**进行封装从而隐藏内部的实现，即外部无法通过了解**内部成员变量**的含义来对成员变量做出对应的修改，必须通过**函数**的方式对类属性进行修改

使用数据抽象类型（ADTs）的作用：

1. 可以隐藏细节。
2. 改动不会影响到整个程序。（当多个其他的类同事依赖于数据抽象类型时，只需通过修改对应的函数或方法就可以对整体进行修改）
3. 让函数尽可能的提供更多的信息。
4. 更容易调高性能。（如果需要提供性能只需要提高ADTs对应的函数的性能就可以提高整体的性能）
5. 让程序的正确性更显而易见。
6. 程序将会更有自说明性。
7. 无须再程序内到处传递数据。（通常只需要传递一个类即可将其内部的ADTs进行间接的传递，从而提高了数据的传递效率）
8. 你可以像在现实世界中那样操作实体，而不需要从底层实现上去操作它。

创建ADTs的指导建议：

1. 把常见的底层数据类型创建为ADT并通过ADT提供的函数来使用这些底层数据类型。
2. 把像文件这样的常用对象当作ADT
3. 简单的事物也可以当作ADT
4. 不要让ADT依赖于其存储介质。

通过以上叙述，可以了解到ADTs在面向对象中常见的使用方式是通过访问控制符public、private来进行控制（事实上，我认为protect的继承方式会影响一个类的封装性）。

## 6.2 良好的类接口（Good Class Interfaces）

### 好的抽象（Good Abstract）

一个类所公开出来的类成员函数应该尽可能的展现同一层次的抽象。

好的抽象可以用到的方法：

1. 类的公开的成员函数应尽可能的展示一致的抽象层次。（举例：假设对于一个类的职责是用于操作文件，如果这个类拥有一个文件列表，则不应该公开存储文件列表的List数据结构的成员函数，而是公开操作文件这个类的函数）
2. 一定要理解类所实现的抽象是什么。（即将假设一个类的职责是用于操作文件，则该类的提供的抽象能力不是是操作列表数据结构，如addListItem等操作）
3. 合理的提供成对的服务。（如一个类是将灯进行开/关，则需要同时提供开启和关闭两个公开函数）
4. 把不相关的信息转移到其他的类中
5. 尽可能让接口可编程，而非**表达语义**（表达语义的含义：对于一个公开的方法应该尽可能的不依赖于一些其他的前置条件，如：该类的begin函数必须依赖于init函数的调用才能工作。）。（正如刚刚的例子，由于begin函数必须依赖于init函数才能调用，那么可以在函数的入参添加一个init参数，通过begin本身来调用init函数从而减少**表达语义**。如果函数必须表达语义，则必须让该函数进行相应的检查以确保begin函数调用之前已经调用了init函数）
6. 谨防在修改时破坏接口的抽象。（当对类进行修改或拓展时，常常发现会加入一些本不属于该类的函数。可看上去缺也很难使用另一种方式来实现。[在重构一章中会进行讲解]）
7. 不要添加于接口抽象不一致的公开函数
8. 同时考虑抽象性和内聚性

### 良好的封装

常用的良好封装的方法：

1. 尽可能的限制类和类属性的访问性
2. 不要公开暴露成员数据
3. 不要对类的使用者做出任何假设
4. 避免使用友元类
5. 不要因为一个函数里只使用公开的函数就将其加入到公开的函数中
6. 让阅读代码比编写代码更方便
7. 要格外警惕从语义上破坏封装性
8. 留意过于紧密的耦合

### 有关设计和实现的问题

#### 包含

尽可能的使用“has a”的方式来实现功能的继承，而非使用“is a”的方式。

其主要的注意事项有：

1. 通过包含来实现“has a”的关系。（如：猫可以拥有一双爪子，而非继承的方式来表达猫是一个爪子）
2. 在万不得已时使用私有继承的方式来实现“has a”的关系。（注：很多语言并不支持这种能力）
3. 警惕超过有7个成员变量的类。（这个有待商榷吧）

#### 继承

首先，继承的概念：是一类对另一个类的特化。

使用继承的注意事项：

1. 用公开的继承来实现“is a”的关系
2. 要使用继承并详细进行说明，要么就不要用它
3. 请遵循里氏替换原则（除非子类真的是父类的一个特化，否则不要使用继承）
4. 确保继承需要继承的部分
5. 不要覆盖一个不可覆盖的函数。（如一个父类私有的函数被子类用相同的函数名进行了覆盖）
6. 把公共的接口、数据及操作尽可能的放到继承树中尽可能高的位置。（具体多高算高：当如果该方法所处的继承树位置会破坏该位置的抽象性时，则就应该停下）
7. 只有一个实例的类是值得怀疑的。（单例设计模式除外）
8. 只有一个子类的父类是值得怀疑的。（这里可以描述为不应该做提前的过度设计）
9. 子类覆盖了某个函数后，但在该函数中没有做任何操作，这种情况值得进行怀疑。
10. 避免让继承体系过深。
11. 尽量使用多态，从而减少大量的类型检查。
12. 让所有的数据都是私有的。

**为什么有这么多关于继承的规则：**

因为继承会无形中增加复杂度，而程序最应该控制的就是复杂度的问题。而以下情况则区分了继承和包含的一些用法：

1. 如果多个类共享数据而非共享行为，则应该为这些类创建一个包含公共的数据对象。
2. 如果多个类共享行为而非共享数据，则应该让它们从共同的父类中继承而来，并在父类定义公共的函数。
3. 如果多个类即共享数据又共享行为，则应该让它们从共同的父类中继承而来，并在父类中定义公共的函数以及包含公共的数据对象。
4. 当你想由父类控制接口时，使用继承；当你想自己控制接口时，使用包含。

#### 成员函数和数据成员（类的函数以及类的数据）

实现类的函数以及类的数据时的一些指导建议：

1. 让类中的成员函数尽可能的少
2. 禁止隐式的产生你不需要的成员函数和运算符（即当某些类需要进行隐藏，则应该将其设置为私有的类。使其无法从外部直接进行创建）
3. 减少类所调用的不同函数的数量
4. 对其他类的函数的间接调用要尽可能少（如：A对象->B对象->C对象->执行（A，B，C对象都被耦合在了一起），这种应该尽可能的避免。这样的好处是尽可能的使类与类之间解耦。）
5. 一般来说，应该减小类和类之间相互合作的范围

#### 构造函数

关于构造函数的指导意见：

1. 如果可能，应该在所有的构造函数中初始化所有的数据成员
2. 用私有构造函数来强制实现单例设计模式
3. 优先采用深拷贝，除非论证可行，才采用浅拷贝。（采用深拷贝可以确保数据的安全性，而浅拷贝主要考虑的则是性能问题。而对于未来未可知的性能问题，应该优先考虑安全性问题）

### 创建类的原因

可能我们认为创建类的原因是为了对物理世界的事物建立对应的模型。则事实上，原因远不止如此。下面就列举一些创建类的原因：

1. 为现实世界中的对象建模。
2. 为抽象的对象建模。（如：形状、颜色、进制转换等抽象概念）
3. 降低复杂度。（创建一个类后可以将细节隐藏在内部，从而使外部无需了解内部细节以减少复杂度）
4. 隔离复杂度。（即当一个类出错后可以将复杂的错误保留在类的内部从隔离复杂度）
5. 隐藏实现细节。
6. 限制变动的影响范围。
7. 隐藏全局数据。
8. 让参数传递更顺畅。（传递一个类比传递多个参数会更好，并且新增的参数如果保留在类中，则无需改动函数的声明）
9. 建立中心控制点。（即可以在一个类中控制某一项任务，从而将所有操作都保留在类中，）
10. 让代码更易于重用（即这个类如果是通用的类，则可以在其他的地方也派上用场）
11. 把相关操作放到一起。（如将计算三角函数的函数包装到一个类中）
12. 实现某种特定的重构。

#### 应该避免的类

1. 避免创建万能类。（即一个类需要有明确的功能）
2. 消除无关性要的类。（一个类如果只包含数据而不包含行为，则它应该考虑它是否是一个真正的类）
3. 避免用动词命名的类。（一个类如果使用了动词进行修饰，则应该考虑这个类是否可以转换为函数）

### 比类更大的范围概念：包（package）

包是一个比类更为抽象的概念，其抽象能力将比类更加强大。其功能是类更进一步的进行归类。

### 关键点

* 类的接口应该提供一直的抽象。
* 类的接口应该隐藏一些信息。
* 包含往往比继承更为可取。
* 继承是一种有用的工具，但它却会增加复杂度，这有悖于软件首要技术使命——管理复杂度。
* 类是管理复杂度的首要工具。要在设计类时给予足够的关注，才能实现这一目标。

# 高质量的子程序

问题1:什么是子程序?

子程序是为了实现一个特定的目的而编写的一个可以被调用的方法、函数、宏等。

一个低质量的子程序一般会出现的问题：

1. 这个子程序的命名很差。
2. 这个子程序没有对应的文档。
3. 这个子程序没有良好的布局。或没有统一一个风格。
4. 如果一个入参是不可修改的要么用const进行修饰，要么采用值传递，要么进行必要的说明。
5. 一个子程序读取的全局变量。
6. 一个子程序没有单一的目的。即一个子程序只完成一件事。
7. 子程序没有注意防范错误数据。
8. 一个子程序读取了若干的魔数（magic number）
9. 一个子程序中未使用所有的参数
10. 参数的传递方式有误
11. 一个子程序有太多的参数
12. 一个子程序的参数顺序混乱且没有进行注释

## 7.1 创建子程序的正当理由

1. 降低复杂度。（使用子程序将复杂度隐藏在子程序的内部，从而在外部无需关心其内部的复杂度）
2. 引入中间、易懂的抽象。（如写了一个遍历数据的代码段，则可以将其转换为遍历数据的子程序并进行相应的命名，从而提供了更高层次的抽象）
3. 避免代码重复。
4. 支持子类化。（覆盖简短的子程序比覆盖冗长的子程序要方便的多）
5. 隐藏顺序。（将程序的语义隐藏在子程序中从而降低复杂度）
6. 隐藏指针操作。
7. 提高可移植性。
8. 简化复杂的布尔判断。（通过子程序将布尔判断进行包装提高可读性）
9. 更容易改善性能。（可以通过一个地方的代码优化提高整体的运行效率）
10. 确保所有的子程序都很小。（这个有点瞎扯，有些时候一个长的子程序会更好）

### 似乎过于简单而没必要写成子程序的操作

一个过于简单的操作也可能逐渐演变成一个复杂的操作，如果采用了子程序的方式进行操作，则可以只修改子程序从而完成所有地方的修改。

小贴士：很多创建类的正当理由也是创建子程序的正当理由

## 7.2 在子程序层上设计

封装和抽象是内聚性这个概念的具体体现。封装和抽象一般是体现在类上的内聚性，而在子程序的这个层次上，则有另一种内聚性的体现。

程序内聚性指的是各个子程序相互依赖的紧密程度。对于一个子程序如果依赖的外部子程序越少，则内聚性越强。所以我们的目标是让一个子程序只把一件事做好，而不再做任何其他的事情。

以下有几个内聚性的层次概念：

1. 功能的内聚性。（这种内聚性最强也是最好的，让一个子程序只执行一项操作。不过前提是子程序执行的操作和其命名相符：若这个子程序还做了其他操作则它不够内聚，并且命名也存在问题）
2. 顺序内聚性。（指的是在子程序中要包含特定顺序执行的操作，需要在全部执行完成后才能完成完整功能）
3. 通讯上的内聚性。（指在一个子程序的不同操作使用了相同的数据。但不同的操作本身没有任何联系）
4. 临时内聚性。（指一些原因需要放到一起执行的操作。这种内聚性认为是不可取的，因为这个子程序本身违背了一个子程序只做一件事情的原则，好的方式应该是将内部的多个不同的操作转为多个子程序，并由原来的子程序进行调用完成）

