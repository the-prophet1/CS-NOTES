# 第一章 概述

1. 对于现代的数据库而言，存在的一些误区
   * **索引层级不要超过5层：**对于一个5层的的索引树，大概能保存几百万个索引，而对于6层的索引树大概能保存上亿个索引。而通常5层的索引树大概会占用的内存大约是几百M，对于现代计算器。拥有如此大的内存，完全可以将5层的索引树放入到内存中，而将第六层的索引放在磁盘中。这样而言依旧能够有足够的查询效率。
   * **单表索引不要超过6个：**那是针对过去磁盘昂贵的问题所遗留的问题，但是现在磁盘空间已经足够大了，所以对于需要使用索引的地方应该尽可能的使用。
   * **不应该索引不稳定的列：**索引不稳定的列容易导致索引树经常发生改变导致更新过慢，但是这个不是不索引的理由，解决方法可以将与之关联的稳定列与不稳定的列进行联合索引，并将尾缀设置为不稳定的列，这样就可以将不稳定的列转为稳定列。并且现在很多索引的部分层级树都已经放到了内存中，极大的加快了这种索引树的更新速度。



# 第二章 表和索引结构

1. 一个查询的数据往往都是层层缓存的： 数据库缓存区 --> 磁盘缓存区 --> 磁盘

2. 数据库查询高达10ms对用户而言是正常的，而对于计算机时昂贵的。

3. 辅助式随机读：

   * 自动跳跃式顺序读：当驱动器或数据引擎发现你读取的区块是顺序的或几乎顺序的，则会顺序预读取多个页。这种预读被称为**动态预读**
   * 列表预读：对于由于索引是顺序的，所以对索引是进行顺序预读取，然后根据对应的索引再依次进行随机读取。
   * 数据块预读：和列表预读类似，只不过数据库读取是先将收集需要查询的索引，然后通过并行随机读取的方式进行。这种读取适用于多磁盘驱动器

4. B树索引结构的替代品：位图索引、散列。位图索引的优势和劣势：

   * 优势：位图索引很适合做与和或运算，并且速度非常快；对于**谓词**（查询条件）很多的查询，位图会很快；更新操作是批量进行的，不存在锁的竞争；
   * 劣势：每次访问都必须访问表行。

   散列的优势和劣势：

   * 优势：查询速度非常快，每次查询平均只需要1次IO就可以查询到结果
   * 劣势：要时时刻刻监视散列的使用率，并且无法支持范围查询



# 第三章 SQL处理过程

1. 定义：**索引片** -- 使用索引匹配到的列数量
2. 对于多谓词查询，有些索引谓词是无法参与到定义索引片的过程中的，即无法使用该谓词减少索引片的厚度。其只在索引片参与到索引片的过滤过程。
3. 对于优化器的监控，可以使用EXPLAIN工具



# 第四章 为SELECT语句创建理想的索引

1. 一个不合适的索引可能导致比全表扫描更差的性能

2. 三星索引：即访问该索引的时候就已经获取到了需要的数据：

   1. 第一颗星：所有等值谓词的列都放到索引的开头列
   2. 第二颗星：将ORDER BY列加入到索引中索引的结果顺序不变，但是其满足第一颗星。
   3. 第三颗星：将查询语句的结果加入到索引中，从而无需回表查询。

   ``` mysql
   SELECT CNO,FNAME
   FROM CUST
   WHERE LNAME = :LNAME
   	  AND
   	  CITY = :CITY
   ORDER BY FNAME
   -- 该SQL使用（LNAME,CITY,FNAME,CNO）联合索引可满足所有条件，即对于该查询的索引为3星索引
   
   SELECT CNO,FNAME
   FROM CUST
   WHERE LNAME > :LNAME1 AND LNAME < :LNAME2
   	  AND
   	  CITY = :CITY
   ORDER BY FNAME
   -- 该SQL使用（LNAME,CITY,FNAME,CNO）联合索引无法满足第二颗星
   -- 该SQL使用（FNAME,LNAME,CITY,CNO）联合索引无法满足第一颗星
   -- 故需要权衡优先满足有序还是优先满足索引片足够小
   ```

   4. 如果为每个查询都设计索引，将会极大的增加插入、更新、删除的操作的负担。



# 第五章 前瞻性的索引设计

1. 发现不适合的索引方法：
   1. 基本问题法（BQ）
   2. 快速上限法（QUBE）
2. 基本问题法
   * 是否存在一个索引包含了WHERE子句中所有的列？
     * 如果WHERE子句中的列不存在于索引中，则加上后可以至少满足第一颗星。
     * 如果还没有达到性能，则可以将查询涉及到的列全部加入到索引中，以防止回表查询。
     * 如果还没有达到性能，则采取13颗星与23颗星的设计方式设计2种索引用于比较性能
3. 快速上限法
   * 快速评估索引的
4.  当设计索引的时候应该考虑到插入、更新、删除等操作的平均性能。这里需要考虑是否使用满足最低性能索引和最优索引的抉择



# 第六章 影响索引设计过程的因素

1. 对于多个范围谓词的索引，将只能利用第一个范围谓词进行操作，后续的范围谓词只有过滤作用，但是没有索引的作用。
2. 当查询使用到**或**关键字时，则可以称该查询为**非布尔型查询**，而如果查询条件都是**与**，则可称该查询为**布尔型查询**。
3. 对于多个范围谓词的索引，可以将某些范围谓词优化成等值谓词。即加入辅助表，将一些范围谓词的值加入辅助表中，并将多个范围谓词查询优化成等值+范围的查询方式。不过优化总是有代价的，即维护比较麻烦，并且这种优化并不总是好的，只有当前缀索引的过滤因子比较小的时候才会产生较好的效果。



# 第七章 被动式索引设计

1. 被动式索引设计可以尝试从一开始不使用索引再到对数据进行多个索引设计来尝试达到需要的性能。EXPLAIN是一个很好的选择，对于查询的优化参考。

2. 多随机IO通常比对数据排序影响更大。

   

# 第八章 为表连接设计索引

1. 连接查询有2类谓词：本地谓词、连接谓词

2. 连接查询有几类查询方式：

   * 嵌套循环连接
   * 合并扫描
   * 哈希连接

3. 当不存在合适的索引时，访问索引的速度可能不比全表扫描快

4. 对于嵌套循环连接，不可避免的容易在内查询中产生大量的随机IO。除非添加冗余列来将内查询优化.

   * 通常嵌套连接查询会将本地过滤行最小的表作为外层表。

5. 对于合并扫描和哈希连接，主要减少的是随机IO的发生。

6. 当连接查询的性能比较差的时候，可以考虑将冗余列加入到主表中以减少随机IO的次数。但是依旧需要权衡更新操作的频率

   

# 第九章 星型连接

1. 星型连接的数据库表查询指的是一张大表与多张小表进行关联查询。
2. 当数据量比较大时，并且需要频繁查询大量数据的集合时，可以使用汇总表来冗余以提高查询性能。



# 第十章 多索引访问

1. 索引与：根据前面的多索引的查询可知，当一个索引是等值谓词，另一个索引是范围谓词的时候，查询过程会产生大量的随机I/O，**索引与**提供了一个方案，即将满足这2个条件的主键进行聚合排序，然后再将得到的主键进行逐一的访问查询。这种查询过程会产生**跳跃式顺序读**的效果，从而提高IO效率。
   * 索引与存在的缺陷：
     1. 当一个谓词的过滤因子较高时，则会顺序访问的数据量存在过多的问题。
     2. 如果一个索引只收集了指向表行的指针，则对其排序则无效，因为这种排序无利于对主键的排序区分。
2. 索引或：对于**或**的查询谓词，由于查询谓词不能很好的进行过滤数据，所以可能类似上述的查询方式对于非布尔查询有更好的效果。



# 第十一章 索引和索引重组

1. B树索引的物理结构：一颗平衡多叉树。通常每个索引页是4k或8k大小。并且对于非唯一索引，通常一个索引值会保存多个指向表行的指针，该指针列表通常会以其值进行排序存储。
2. 随着索引的删除和更新，索引树索引的逻辑顺序逐渐与磁盘的物理顺序不同，从而导致当需要获取索引片时会导致随机IO的增加，从而影响索引性能。
3. 对于是否应该周期性的对索引进行重组应该结合实际情况以于讨论。当时通常情况下当数据规模大到一定程度并且索引更新很频繁，并且从监控处发现访问索引时出现了大量的随机IO就应该对索引进行重建。



# 第十二章 数据库管理系统相关的索引限制

略



# 第十三章 数据库索引选项

略



# 第十四章 优化器不是完美的

略

# 第十五章 其他评估事项

略

# 第十六章 组织索引设计过程

设计出色索引的步骤：

1. 选择主键索引、外键索引、候选索引（可选）
2. 评估理想索引的时间，若无法满足效率，则可以考虑反范式化，新增一些冗余数据以提高查询效率。
3. 当表结构稳定后，开始添加一些必要的索引。
4. 若一个表经常性的发生更新，删除，插入。则应该评估最多可以容纳多少个索引
5. 当程序发布后，应对SQL进行EXPLAIN
6. 当系统遇到流量高峰时，应生成对应的异常报告。-



