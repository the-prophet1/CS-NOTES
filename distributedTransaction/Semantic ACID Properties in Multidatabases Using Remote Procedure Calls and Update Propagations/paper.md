# 使用远程过程调用和更新传播的多数据库中的语义ACID属性

## 摘要

全局ACID属性(原子性、一致性、隔离性和持久性)可以通过使用DDBMS(分布式数据库管理系统)来实现。然而，在这个解决方案中，数据可用性很低。此外，数据可能会被阻塞，即如果某些数据从远程节点被锁定，当数据连接失败时，数据不能总是被解锁。当使用客户端/服务端技术时，这不是问题，因为客户端/服务端技术只使用本地锁，这就是为什么多数据库和客户端/服务端技术在现实的分布式系统中被广泛使用的原因。然而，此类系统的问题在于它们没有固有的全局 ACID 属性。本文的目的是说明如何在客户端/服务端技术的基础上实现由事务本身执行的全局语义ACID属性。这样做是为了保持高数据可用性。全局原子性属性是通过使用可重试和可补偿的子事务来实现的。全局一致性属性必须由事务本身实现。全局隔离属性是通过对异常采取对策（**对策**：由应用程序员实现的一种用于处理异常的代码段）来实现的。全局持久性属性是通过使用本地 DBMS 的持久性属性来实现的。丹麦最大的银行 Den Danske Bank 已使用本文中描述的方法实现了所有应用程序。

>  关键词：多数据库； 并发控制； 原子性； 隔离级别； 可用性

## 绪论

多数据库系统 (MDBS) 是一种允许用户访问位于多个独立数据库管理系统 (DBMS) 中的数据的系统。多数据库是本地数据库的联合。全局事务访问位于多个本地数据库中的数据。本地 DB 事务在具有本地 ACID 属性的单个 DBMS 的控制下执行。全局事务则可以由属于分布式数据库管理系统 (DDBMS) 或 MDBS 产品的全局事务管理器 (GTM) 管理。在这种情况下，全局 ACID 属性由 GTM 与本地 DMBS 合作实现。另一方面，客户端/服务端系统没有 GTM，因此本地 DB 事务可能以非协调的方式进行通信。这种方式没有全局 ACID 属性。

在本文中，我们描述了如何在不使用 GTM 的情况下实现全局 ACID 属性。 在实践中，语义 ACID 属性会起作用，即我们只实现应用程序所需的 ACID 属性。 （通常，从应用程序的角度来看，我们可以省去隔离属性。）

据我们所知，目前还没有商业 MDBS 产品可以同时确保数据的高可用性、高性能和事务的语义 ACID 属性。因此，许多公司使用客户端/服务端架构“发明”了自己的解决方案。本文的主要目的是帮助这些公司实现全局语义 ACID 属性。通过使用远程过程调用 (RPC) 和更新传播 (UP) 等高级工具，可以降低实现成本。在没有隔离属性的情况下执行事务时，可能会出现以下隔离异常：

1. 丢失更新异常。
2.  脏读异常。
3.  不可重复读取异常。
4.  幻读异常。

由于我们不使用 GTM，因此必须使用事务管理的对策来处理隔离异常。（即不是完全隔离的措施，而是隔离异常的对策。）因此，在下文中，我们将事务模型称为对策事务模型(The Countermeasure Transaction Model)。由于数据的高可用性和隔离性之间存在冲突，因此事务设计人员应选择尽可能少的隔离异常保护措施，以获得尽可能高的可用性。通常，所有更新事务都必须对*丢失更新异常采取*对策。但是对于许多应用程序来说，选择能够降低使用**脏数据**或**不可重复数据**风险的对策就足够了。当然，有必要了解应用程序的语义，以便为每种事务类型选择适当的对策。事实上，通过在大范围内使用对策，是有可能解决所有隔离异常现象的。但是不建议这样做，因为如果所有的隔离异常都解决了，数据的可用性会降低，使用普通的并发控制会更容易。(如果某些事务需要所有的全局ACID属性，则可以使用DDBMS执行这些事务，并将这些事务与本文中描述的具有全局语义ACID属性的事务穿插在一起使用。)

本论文组织如下：第 2 节将描述对策事务模型，即我们将概述如何实现全局语义 ACID 属性。在第 3 节中，我们通过示例说明如何通过使用对策来减少或消除隔离异常。在第 4 节中，我们描述了如何实现全局原子性属性并将其与对策相结合。在第 5 节中，我们描述了实现更新传播的不同方法，（因为在标准系统中，这种高级工具的实现方式通常无法在对策事务模型中使用。）总结性评论和进一步研究的建议是在第 6 节和第 7 节中介绍。

**相关工作**

Garcia-Molina 和 Salem 于 1987 年首次引入了使用补偿事务的原子性。据我们所知，使用强制方法管理事务的原子性是由 Frank 在 1985 年和 1988 年首次描述的。这两种原子性方法随后被 Mehrotra 在 1992 年和 Zhang 在 1994 年集成到核心事务模型(the pivot transaction models)中。直到Gray and Reuter(1993)和Berenson等人(1995)将隔离特性分解为分离隔离异常，才有可能对本文所描述的对策进行系统分析。

## 对策事务模式

在这个模型中，一个全局事务由一个根事务（客户端事务）和几个执行存储过程或存储程序的节点子事务（服务端事务）组成。子事务本身可以是嵌套事务，即一个子事务可能是其他子事务的父事务。在对策事务模型中，所有与用户的通信都由根事务管理，所有的数据都通过子事务访问。存储在根事务节点的数据也可以通过子事务访问，这由客户端/服务端架构决定。一个子事务可以由几个数据库事务组成，这些数据库事务通过本地提交命令彼此分离。通常一个子事务只包含一个数据库事务，在这种情况下，我们通常不区分子事务和它包含的数据库事务。

所有子事务都通过以下两种高级工具访问：

1. 远程过程调用 (RPC)

   RPC 还没有一个标准，但从程序员的角度来看，它们的功能就像普通的过程调用，只是过程调用和过程本身存储在不同的节点。当父事务执行 RPC 时，它等待子事务执行，当子事务完成时，将结果返回给父事务。如果父事务执行更多 RPC，则相应的子事务一次执行一个（与 UP事务 相反）。在远程节点，子事务作为具有本地 ACID 属性的事务执行。

   因此，RPC 可能会导致以下问题：

   ​	1. 如果父事务没有从子事务中得到结果，则父事务将不知道子事务是已提交还是已中止。

   ​	2. 如果 RPC 执行后父事务失败，则父事务被中止，而子事务仍被提交。

   在这两种情况下，我们都没有实现全局原子性，因此需要下面的 UP 工具。

2. 更新传播 (UP)

   这里的更新传播指的是任何更新(不仅仅是副本)的传播。UP工具的工作原理如下。当使用更新传播执行远程存储的程序时，带参数的调用存储在持久存储(本地DBMS文件)上。底层系统（UP 工具）稍后将读取“调用”并执行相关的存储程序 。如果存储程序执行失败，UP工具会重新启动存储程序，直到它被提交。我们所说存储的程序是可执行的。当且仅当进行UP操作的父事务已经被提交时，子事务才会被执行和提交。

   父事务通过在父节点的持久存储中存储所谓的事务记录来进行 UP。父事务id、子事务id和子事务参数存储在事务记录中。如果父事务失败，事务记录将被回滚，因此子事务将不会被执行。当提交父事务时，事务记录在持久存储中得到保护，我们说UP启动了。UP 发起后，UP 工具（使用通信协议）会读取事务记录并将其发送到相应子事务的节点。如果子事务失败，则重新提交事务记录，直到提交子事务。

   当一个父事务执行多个 UP 时，对应的子事务可以并行执行。

下面，我们将概述如何使用 RPC 和 UP 在对策事务模型中实现全局语义 ACID 属性。

**原子性属性**

如果更新事务的所有更新都被执行或不被执行，则将其称为原子更新事务。在对策事务模型中，全局原子性属性是这样实现的:首先使用几个可补偿的子事务，然后使用一个核心子事务，最后使用几个可重复的子事务，如核心事务模型中描述的那样。

如果子事务的执行在有限的提交次数后保证在本地提交，则子事务是可重试的。UP工具(如上所述)用于重新提交执行请求，直到提交子事务为止，也就是说，UP工具用于强制执行可重试的子事务。

**例子2.1**

银行账户中的存款可以作为可重试的子事务来实现。如果在账户中存入资金有任何限制，（或如果存款账户被关闭），资金可能会存入错误账户，在那里以后的事务将被手工处理。如果可重试子事务失败，将重新提交执行子事务的请求，直到被接受为止。

如果在可补偿子事务的本地提交之后，其执行的效果可以在语义上得到补偿，那么子事务就是可补偿的。补偿通过执行补偿子事务来完成。补偿子事务必须是可执行的，以便可以通过UP执行补偿子事务。

**例子2.2**

从银行账户取款可以作为可补偿的子事务来实现，因为取款可以通过一个补偿子事务来补偿，该补偿子事务存入的金额与从账户中取款的金额相同。

既不能回收也不能补偿的子事务被认为是核心子事务。在对策事务模型中，只能使用一个核心子事务。提交核心子事务时将同时提交全局事务。如果全局事务本质上没有核心子事务，则可以选择最后一个可补偿或第一个可重试子事务作为核心子事务。可补偿子事务在核心事务提交之前在本地提交，所有可重试子事务在核心子事务提交之后在本地提交。

